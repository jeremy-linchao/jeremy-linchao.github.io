<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>学习学习再学习</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="学习学习再学习">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="学习学习再学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习学习再学习">
  
    <link rel="alternate" href="/atom.xml" title="学习学习再学习" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学习学习再学习</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-node/Node 学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/10/node/Node 学习/" class="article-date">
  <time datetime="2016-12-10T01:14:33.000Z" itemprop="datePublished">2016-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-学习"><a href="#Node-学习" class="headerlink" title="Node 学习"></a>Node 学习</h1><ol>
<li><p>Stream： 什么是stream？stream翻译过来是流，也就是说所有的网络或者文件读取的东西都是可以不过内存来处理，比如网络上传的文件，文件的每一部分被读取到都可以直接写到磁盘里，而不用说需要先把整个文件读到内存然后再写磁盘，一个典型的读取磁盘文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var file = fs.createReadStream(&apos;fruits.txt&apos;);</div><div class="line">file.on(&apos;readable&apos;,function()&#123;</div><div class="line">  var chunk = null;</div><div class="line">  while((chunk=file.read())!==null)&#123;</div><div class="line">    console.log(chunk.toString());      </div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Module:  module.exports = a; 这样写的话在文件中只能导出一个函数，如果要导出多个函数，需要写成这样</p>
<p>module.exports.a = a;</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/10/node/Node 学习/" data-id="ciwzy640i000v1ozservtgfgi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git/Git reset 和 git checkout 的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/09/git/Git reset 和 git checkout 的区别/" class="article-date">
  <time datetime="2016-12-09T06:54:13.000Z" itemprop="datePublished">2016-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-reset-和-git-checkout-的区别"><a href="#Git-reset-和-git-checkout-的区别" class="headerlink" title="Git reset 和 git checkout 的区别"></a>Git reset 和 git checkout 的区别</h1><ol>
<li><p>git chekout 是用来移动HEAD指向不同的分支，git reset是在同一个分支内移动HEAD头</p>
</li>
<li><p>git reset - - soft HEAD~  只移动HEAD到那个commit，注意此时staged区和工作目录并没有被重置</p>
<p>git reset - - mixed HEAD~  移动HEAD到那个commit，staged被重置到那个commit，但工作目录没有</p>
<p>git reset - -hard HEAD~ 移动HEAD到那个commit，并且同时重置staged区域以及工作目录，这个因为会覆盖工作目录会有一点风险性，如果你当前修改的东西没有commit然后hard的话当前的找不到，当然如果是简单想回去看看，那是没有问题的</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/09/git/Git reset 和 git checkout 的区别/" data-id="ciwzy63zg000g1ozs1qjow6vk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mac/Mac下启动和重启nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/08/mac/Mac下启动和重启nginx/" class="article-date">
  <time datetime="2016-12-08T08:43:59.000Z" itemprop="datePublished">2016-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Nginx in Mac</p>
<p>通过homebrew 安装的nginx其实是可以通过brew services来管理的</p>
<p>终端下敲一个brew services可以看到具体的用法比如</p>
<p>brew services [start|restart|stop] nginx </p>
<p><strong>如果nginx是run在80端口，需要加sudo</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/08/mac/Mac下启动和重启nginx/" data-id="ciwzy640f000r1ozszpz9ztq9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-es6/ES6学习(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/07/es6/ES6学习(2)/" class="article-date">
  <time datetime="2016-12-07T09:53:59.000Z" itemprop="datePublished">2016-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ES6学习-2"><a href="#ES6学习-2" class="headerlink" title="ES6学习(2)"></a>ES6学习(2)</h1><ol>
<li><p>Set类型</p>
<p>Set：类似于数组，但成员值是唯一的，没有重复的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var set = new Set([1, 2, 3, 4, 4]);</div><div class="line">[...set]</div><div class="line">// [1, 2, 3, 4]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个例子展示了一种数组去重的方法[…new Set(array)]</p>
<ol>
<li><p>Map类型</p>
<p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var data = &#123;&#125;;</div><div class="line">var element = document.getElementById(&apos;myDiv&apos;);</div><div class="line"></div><div class="line">data[element] = &apos;metadata&apos;;</div><div class="line">data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>Symbol类型： 表示一个独一无二的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div><div class="line">typeof s</div><div class="line">// &quot;symbol&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>Proxy：用于修改某些操作的默认行为，可以理解成在目标对象之前假设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get: function (target, key, receiver) &#123;</div><div class="line">    console.log(`getting $&#123;key&#125;!`);</div><div class="line">    return Reflect.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: function (target, key, value, receiver) &#123;</div><div class="line">    console.log(`setting $&#123;key&#125;!`);</div><div class="line">    return Reflect.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Generator函数：Generator函数是一个状态机，封装了多个内部状态，执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
<p>1）定义上，Generator函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>语句，定义不同的内部状态</p>
<p>2）调用上，是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>
<p>3）下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>语句（或<code>return</code>语句）为止</p>
</li>
<li><p>Promise就是个容器，里面保存着某个未来才会结束的事件的结果</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   <code>resolve</code>函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>   Promise实例生成以后，可以用<code>then</code>方法分别指定<code>Resolved</code>状态和<code>Reject</code>状态的回调函数</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   <code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数</p>
<p>   我的理解：两个重要的参数，resolve和reject是两个函数，这两个函数在创建了promise对象后需要显式调用下将函数返回的值作为传出去</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/07/es6/ES6学习(2)/" data-id="ciwzy640h000t1ozsqwcoqsad" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ide/WebStorm 下设置支持ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/07/ide/WebStorm 下设置支持ES6/" class="article-date">
  <time datetime="2016-12-07T02:05:10.000Z" itemprop="datePublished">2016-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WebStorm-下设置支持ES6"><a href="#WebStorm-下设置支持ES6" class="headerlink" title="WebStorm 下设置支持ES6"></a>WebStorm 下设置支持ES6</h1><p>说句题外话，vscode和webstorm我都使用了一些，特别一开始因为vscode是免费的所以很支持，但我觉得在用户体验上vscode真的差的很多，几个直观感受</p>
<ol>
<li><p>设置node的版本： 在webstorm的preferrence上可以直接设置，vscode我是没有很容易找到，应该是要在配置文件里设置</p>
</li>
<li><p>ES6语法支持：在webstorm下可以直接在perference上配置，vscode得在项目根目录下建立一个jsconfig文件</p>
</li>
<li><p>另外要特别注意的一点是除了要设置IDE，node的版本也需要关注下，下面这个链接是node不同版本对于ES6的支持程度</p>
<p><a href="http://node.green/" target="_blank" rel="external">http://node.green/</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/07/ide/WebStorm 下设置支持ES6/" data-id="ciwzy640e000q1ozsxb4tl3av" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git/Git Rebasing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/git/Git Rebasing/" class="article-date">
  <time datetime="2016-12-06T09:33:30.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-Rebasing"><a href="#Git-Rebasing" class="headerlink" title="Git Rebasing"></a>Git Rebasing</h1><h4 id="什么叫Rebasing：-take-the-patch-of-the-change-that-was-introduced-in-C4-and-reapply-it-on-top-of-C3"><a href="#什么叫Rebasing：-take-the-patch-of-the-change-that-was-introduced-in-C4-and-reapply-it-on-top-of-C3" class="headerlink" title="什么叫Rebasing： take the patch of the change that was introduced in C4 and reapply it on top of C3"></a>什么叫Rebasing： take the patch of the change that was introduced in C4 and reapply it on top of C3</h4><p>不是太理解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/git/Git Rebasing/" data-id="ciwzy63zf000f1ozson5r4izz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-es6/ES6 学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/es6/ES6 学习/" class="article-date">
  <time datetime="2016-12-06T08:09:04.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ES6-学习-1"><a href="#ES6-学习-1" class="headerlink" title="ES6 学习(1)"></a>ES6 学习(1)</h1><ol>
<li><p>let用来声明块级作用域变量。let不会像var那样发生变量提升，所以一定要在声明后使用。另外在一个块级作用域内如果用let声明了一个局部变量，那么这个变量会绑定这个块级作用域，所有在let变量声明前对该变量的操作都会报错</p>
<p><strong><em>为什么需要块级作用域？</em></strong> 先来看下没有块级作用域带来的几个问题</p>
<p>1） 内层变量可能会覆盖外层变量，或者说外层的变量不会受内层变量影响，下面这个例子console.log（tmp）这个tmp就被内层的tmp影响了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var tmp = new Date();</div><div class="line"></div><div class="line">function f() &#123;</div><div class="line">  console.log(tmp);</div><div class="line">  if (false) &#123;</div><div class="line">    var tmp = &quot;hello world&quot;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); // undefined</div></pre></td></tr></table></figure>
<p>2)   用来计数的循环变量泄露为全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = &apos;hello&apos;;</div><div class="line"></div><div class="line">for (var i = 0; i &lt; s.length; i++) &#123;</div><div class="line">  console.log(s[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(i);</div></pre></td></tr></table></figure>
</li>
<li><p>const命令：声明一个只读的常量。一旦声明，常量的值就不能改变。声明后必须立即初始化</p>
</li>
<li><p><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；而<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性</p>
</li>
<li><p>解构赋值（Destructuring):  按照一定模式，从数组和对象中提取值，对变量进行赋值</p>
<p>如果为多个变量赋值，原先需要这样写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var b = 2;</div><div class="line">var c = 3;</div></pre></td></tr></table></figure>
<p>但现在可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var [a, b, c] = [1, 2, 3];</div></pre></td></tr></table></figure>
<p>也可以为对象来解构赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">foo // &quot;aaa&quot;</div><div class="line">bar // &quot;bbb&quot;</div><div class="line"></div><div class="line">var &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">baz // undefined</div></pre></td></tr></table></figure>
<p><strong><em>那些场景下使用解构比较好呢?</em></strong></p>
<p>1)  交换变量的值： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<p>2）提取JSON数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var jsonData = &#123;</div><div class="line">  id: 42,</div><div class="line">  status: &quot;OK&quot;,</div><div class="line">  data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, &quot;OK&quot;, [867, 5309]</div></pre></td></tr></table></figure>
</li>
<li><p>函数参数的默认值：</p>
<p>在ES6之前，不能直接为函数的参数指定默认值，只能用变通的方法</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function log(x, y) &#123;</div><div class="line">  y = y || &apos;World&apos;;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</div></pre></td></tr></table></figure>
<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值 ，就像这个例子中的第三个log函数，很明显是想打一个空值，但最后被打成了默认值，而在ES6中可以直接这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = &apos;World&apos;) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</div></pre></td></tr></table></figure>
<ol>
<li><p>rest参数</p>
<p>这个例子下，theArgs是一个数组，数组的内容是从第三个开始到最后的所有参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function(a, b, ...theArgs) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f = v =&gt; v;</div></pre></td></tr></table></figure>
<p>这个写法等同于如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f = function(v) &#123;</div><div class="line">  return v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = () =&gt; 5;</div><div class="line">// 等同于</div><div class="line">var f = function () &#123; return 5 &#125;;</div><div class="line"></div><div class="line">var sum = (num1, num2) =&gt; num1 + num2;</div><div class="line">// 等同于</div><div class="line">var sum = function(num1, num2) &#123;</div><div class="line">  return num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>箭头函数使用场景</strong></p>
<p>1） 简化回调函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 正常函数写法</div><div class="line">[1,2,3].map(function (x) &#123;</div><div class="line">  return x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 箭头函数写法</div><div class="line">[1,2,3].map(x =&gt; x * x);</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var result = values.sort(function (a, b) &#123;</div><div class="line">  return a - b;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 箭头函数写法</div><div class="line">var result = values.sort((a, b) =&gt; a - b);</div></pre></td></tr></table></figure>
<p>使用注意点：</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>
<p>针对于第一点的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    console.log(&apos;id:&apos;, this.id);</div><div class="line">  &#125;, 100);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var id = 21;</div><div class="line"></div><div class="line">foo.call(&#123; id: 42 &#125;);</div><div class="line">// id: 42</div></pre></td></tr></table></figure>
</li>
<li><p>for … of 循环</p>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<p>​</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/es6/ES6 学习/" data-id="ciwzy640i000u1ozsxvyrflxc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javascript/Javascript 数组类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/javascript/Javascript 数组类型/" class="article-date">
  <time datetime="2016-12-06T03:07:49.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Javascript-数组"><a href="#Javascript-数组" class="headerlink" title="Javascript 数组"></a>Javascript 数组</h1><p>​    js的数组和其他语言的数组类型相差还是很大，<strong>其一</strong>表现在js的数组并不要求一个数组内的数据类型都是一致，如下的数组定义是没有问题的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">"abc"</span>,<span class="number">5.6</span>,&#123;<span class="string">'name'</span>:<span class="string">'lin'</span>&#125;];</div><div class="line"><span class="built_in">console</span>.log(a)</div></pre></td></tr></table></figure>
<p><strong>其二</strong>表现在数组的长度length这个属性不仅仅是只读的，也是可写的，比如上面的代码改为,这样就只会打印出两个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.length = 2;</div><div class="line">console.log(a)</div></pre></td></tr></table></figure>
<p>​    数组的栈方法：push(), pop() </p>
<p>​        数组的队列方法：push(),unshift()       数组末进入，数组头出</p>
<p>​                                       unshift(), pop()        数组头进入，数组末尾处</p>
<p>​    数组排序方法：sort()  接收一个compare函数， 比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2)&#123;</div><div class="line">  if (value1 &lt; value2)&#123;</div><div class="line">    return -1;</div><div class="line">  &#125; else if (value1 &gt; value2)&#123;</div><div class="line">    return 1;</div><div class="line">  &#125; else &#123;</div><div class="line">    return 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    数组concat方法：这个方法先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()传递参数的情况下，它只是复制当前数组并返回副本</p>
<p>​    数组slice() 方法：接收一个或两个参数，如果是一个参数，就返回从这个索引到数组末尾的整个一个新数组，如果是两个参数，就返回从第一个索引到第二参数-1这个索引的新数组</p>
<p>​       数组splice()方法：1）删除：2个参数，第一项的位置    和要删除的项数    2）插入：3个参数， 起始位置，0（要删除的项数），要插入的项  3）替换</p>
<p>​      数组 indexOf() 方法：接收两个参数，要查找的项和表示查找起点的索引(索引)</p>
<p>​      数组迭代方法：every(),filter(),forEach(),map(),some()   每个传入的函数接收三个参数，数组项的值，该项在数组中的位置，数组对象本身</p>
<p>​      数组reduce() 方法：每个传入的函数接收4个参数：前一个值，当前值，项的索引和数组对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/javascript/Javascript 数组类型/" data-id="ciwzy640p00141ozst0zuqt2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javascript/Javascipt 变量基本类型与引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/javascript/Javascipt 变量基本类型与引用类型/" class="article-date">
  <time datetime="2016-12-06T02:08:31.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Javascipt-变量基本类型与引用类型"><a href="#Javascipt-变量基本类型与引用类型" class="headerlink" title="Javascipt 变量基本类型与引用类型"></a>Javascipt 变量基本类型与引用类型</h1><h3 id="Javascript的变量分为基本类型和引用类型，基本类型有Number-String-Boolean-Null-Undefined-引用类型有Object-Array-Date"><a href="#Javascript的变量分为基本类型和引用类型，基本类型有Number-String-Boolean-Null-Undefined-引用类型有Object-Array-Date" class="headerlink" title="Javascript的变量分为基本类型和引用类型，基本类型有Number,String,Boolean,Null,Undefined, 引用类型有Object,Array,Date"></a>Javascript的变量分为基本类型和引用类型，基本类型有Number,String,Boolean,Null,Undefined, 引用类型有Object,Array,Date</h3><h3 id="引用对象和java很像，就是对象本身是创建在内存的堆之上的，然后有一个变量保存的是对这个对象的引用或者说是一个指针"><a href="#引用对象和java很像，就是对象本身是创建在内存的堆之上的，然后有一个变量保存的是对这个对象的引用或者说是一个指针" class="headerlink" title="引用对象和java很像，就是对象本身是创建在内存的堆之上的，然后有一个变量保存的是对这个对象的引用或者说是一个指针"></a>引用对象和java很像，就是对象本身是创建在内存的堆之上的，然后有一个变量保存的是对这个对象的引用或者说是一个指针</h3><h3 id="所有的变量赋值都是按值复制的，意思即是说当var-a-b时，我不管a是个什么类型的变量，都是在内存中创建一个区域a，放的是b本身的值（b如果是基本类型，就把这个基本类型的值放到a；b如果是个引用类型的值，就把b这个引用值存到a，这样a和b都指向了同一个对象"><a href="#所有的变量赋值都是按值复制的，意思即是说当var-a-b时，我不管a是个什么类型的变量，都是在内存中创建一个区域a，放的是b本身的值（b如果是基本类型，就把这个基本类型的值放到a；b如果是个引用类型的值，就把b这个引用值存到a，这样a和b都指向了同一个对象" class="headerlink" title="所有的变量赋值都是按值复制的，意思即是说当var a = b时，我不管a是个什么类型的变量，都是在内存中创建一个区域a，放的是b本身的值（b如果是基本类型，就把这个基本类型的值放到a；b如果是个引用类型的值，就把b这个引用值存到a，这样a和b都指向了同一个对象"></a>所有的变量赋值都是按值复制的，意思即是说当var a = b时，我不管a是个什么类型的变量，都是在内存中创建一个区域a，放的是b本身的值（b如果是基本类型，就把这个基本类型的值放到a；b如果是个引用类型的值，就把b这个引用值存到a，这样a和b都指向了同一个对象</h3><h3 id="函数传递的时候也是按值来传递"><a href="#函数传递的时候也是按值来传递" class="headerlink" title="函数传递的时候也是按值来传递"></a>函数传递的时候也是按值来传递</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/javascript/Javascipt 变量基本类型与引用类型/" data-id="ciwzy640l000y1ozs7quwxf2z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git/远端Branch 12.5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/git/远端Branch 12.5/" class="article-date">
  <time datetime="2016-12-06T02:00:15.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="远端Branch-12-5"><a href="#远端Branch-12-5" class="headerlink" title="远端Branch 12.5"></a>远端Branch 12.5</h1><h3 id="git-fetch-origin"><a href="#git-fetch-origin" class="headerlink" title="git fetch origin"></a>git fetch origin</h3><p>This command looks up which server “origin” is (in this case, it’s <code>git.ourcompany.com</code>), fetches any data from it that you don’t yet have, and updates your local database, moving your <code>origin/master</code> pointer to its new, more up-to-date position.</p>
<h5 id="这个指令会取远端其他分支的更新，同时移动远端的如origin-master指针"><a href="#这个指令会取远端其他分支的更新，同时移动远端的如origin-master指针" class="headerlink" title="这个指令会取远端其他分支的更新，同时移动远端的如origin/master指针"></a>这个指令会取远端其他分支的更新，同时移动远端的如origin/master指针</h5><p>It’s important to note that when you do a fetch that brings down new remote-tracking branches, you don’t automatically have local, editable copies of them. In other words, in this case, you don’t have a new serverfix branch – you only have an origin/serverfix pointer that you can’t modify.</p>
<h5 id="也就是说git-fetch只是将远端的分支数据拿下来，但本地不会创建分支，那个拿下来的代码也是不可编辑的，因此如果要合master的代码还需要再做一步git-merge-origin-serverfix-注意这个origin-servervix指的是已经下到本地的那个copy，有一个origin-serverfix指针。另外如果要根据远端的branch创建一个新的分支，可以git-checkout-b-serverfix-origin-serverfix"><a href="#也就是说git-fetch只是将远端的分支数据拿下来，但本地不会创建分支，那个拿下来的代码也是不可编辑的，因此如果要合master的代码还需要再做一步git-merge-origin-serverfix-注意这个origin-servervix指的是已经下到本地的那个copy，有一个origin-serverfix指针。另外如果要根据远端的branch创建一个新的分支，可以git-checkout-b-serverfix-origin-serverfix" class="headerlink" title="也就是说git fetch只是将远端的分支数据拿下来，但本地不会创建分支，那个拿下来的代码也是不可编辑的，因此如果要合master的代码还需要再做一步git merge origin/serverfix, 注意这个origin/servervix指的是已经下到本地的那个copy，有一个origin/serverfix指针。另外如果要根据远端的branch创建一个新的分支，可以git checkout -b serverfix origin/serverfix"></a>也就是说git fetch只是将远端的分支数据拿下来，但本地不会创建分支，那个拿下来的代码也是不可编辑的，因此如果要合master的代码还需要再做一步git merge origin/serverfix, 注意这个origin/servervix指的是已经下到本地的那个copy，有一个origin/serverfix指针。另外如果要根据远端的branch创建一个新的分支，可以git checkout -b serverfix origin/serverfix</h5><p>While the <code>git fetch</code> command will fetch down all the changes on the server that you don’t have yet, it will not modify your working directory at all. It will simply get the data for you and let you merge it yourself.</p>
<h5 id="git-fetch不会修改working-directory"><a href="#git-fetch不会修改working-directory" class="headerlink" title="git fetch不会修改working directory"></a>git fetch不会修改working directory</h5><h3 id="git-push-origin-serverfix-awesomebranch"><a href="#git-push-origin-serverfix-awesomebranch" class="headerlink" title="git push origin serverfix:awesomebranch"></a>git push origin serverfix:awesomebranch</h3><p> push your local <code>serverfix</code> branch to the <code>awesomebranch</code> branch on the remote project</p>
<h3 id="git-checkout-b-branch-remote-branch"><a href="#git-checkout-b-branch-remote-branch" class="headerlink" title="git checkout -b branch remote/branch"></a>git checkout -b branch remote/branch</h3><h5 id="这个命令用来在创建分支的时候设置远程的upstream-branch，也可以用这个git-checkout-–track-origin-serverfix，甚至可以简写成git-checkout-serverfix在满足以下两个条件的情况下，-a-新创建的分支名本地不存在-doesn’t-exist-and-b-分支名远端server就只有这么一个-exactly-matches-a-name-on-only-one-remote"><a href="#这个命令用来在创建分支的时候设置远程的upstream-branch，也可以用这个git-checkout-–track-origin-serverfix，甚至可以简写成git-checkout-serverfix在满足以下两个条件的情况下，-a-新创建的分支名本地不存在-doesn’t-exist-and-b-分支名远端server就只有这么一个-exactly-matches-a-name-on-only-one-remote" class="headerlink" title="这个命令用来在创建分支的时候设置远程的upstream branch，也可以用这个git checkout –track origin/serverfix，甚至可以简写成git checkout serverfix在满足以下两个条件的情况下，(a) 新创建的分支名本地不存在 doesn’t exist and (b) 分支名远端server就只有这么一个 exactly matches a name on only one remote,"></a>这个命令用来在创建分支的时候设置远程的upstream branch，也可以用这个git checkout –track origin/serverfix，甚至可以简写成git checkout serverfix在满足以下两个条件的情况下，(a) 新创建的分支名本地不存在 doesn’t exist and (b) 分支名远端server就只有这么一个 exactly matches a name on only one remote,</h5><h3 id="git-fetch-all-git-branch-vv"><a href="#git-fetch-all-git-branch-vv" class="headerlink" title="git fetch - - all   git branch -vv"></a>git fetch - - all   git branch -vv</h3><h5 id="查看本地的tracking-branch和远端的upstream-branch关系"><a href="#查看本地的tracking-branch和远端的upstream-branch关系" class="headerlink" title="查看本地的tracking branch和远端的upstream branch关系"></a>查看本地的tracking branch和远端的upstream branch关系</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/git/远端Branch 12.5/" data-id="ciwzy63zn000k1ozs33lqdkqa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习学习再学习/">学习学习再学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习学习再学习/" style="font-size: 10px;">学习学习再学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/21/utility/Markdown 学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/12/21/coding/函数式编程/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/12/21/coding/高阶函数与偏函数/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/12/21/coding/关于异步/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/12/20/es6/ES6 Generate 函数/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 jeremy-lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>